package main

import (
	"fmt"
	"log"
	"regexp"

	"github.com/alextanhongpin/pkg/gen"
	"github.com/dave/jennifer/jen"
	. "github.com/dave/jennifer/jen"
)

const Generator = "reader"

var (
	tagRe *regexp.Regexp
)

func init() {
	tagRe = regexp.MustCompile(`read:"-"`)
}

func main() {
	if err := gen.New(generateStructFromFields); err != nil {
		log.Fatalln(err)
	}
}

func skipField(tag string) bool {
	return tagRe.MatchString(tag)
}

func generateStructFromFields(opt gen.Option) error {
	var (
		pkgName    = opt.PkgName
		pkgPath    = opt.PkgPath
		out        = opt.Out
		structName = opt.StructName
		fields     = opt.Fields
	)
	f := NewFile(pkgName) // e.g. main
	f.PackageComment(fmt.Sprintf("Code generated by %s, DO NOT EDIT.", Generator))

	for _, field := range fields {
		if field.Exported {
			continue
		}
		if skipField(field.Tag) {
			continue
		}
		generateGetter(f, pkgPath, structName, field)
	}

	return f.Save(out) // e.g. main_gen.go
}

func generateGetter(f *jen.File, pkgPath, structName string, field gen.StructField) {
	// Output:
	// func (e YourStruct) Name() string {
	// 	return e.name
	// }

	shortName := gen.LowerFirst(structName)[:1]
	f.Func().Params(
		// (e YourStruct)
		Id(shortName).Id(structName),
	).Id(
		// Name
		gen.UpperCommonInitialism(field.Name),
	).
		Params().Add(generateType(pkgPath, field.Field)).
		Block(
			Return(Id(shortName).Dot(field.Name)),
		).Line()
}

// Generate the field and type for primitive, map or collection.
func generateType(pkgPath string, field *gen.Field) Code {
	param := Op("")
	if field.IsMap {
		key, value := field.MapKey, field.MapValue
		param = param.Map(generateType(pkgPath, key))
		param = param.Add(generateType(pkgPath, value))
		return param
	}
	if field.IsCollection {
		param = param.Index()
	}
	if field.IsPointer {
		param = param.Add(Op("*"))
	}
	param = param.Qual(gen.SkipCurrentPackagePath(pkgPath, field.PkgPath), field.Type)
	return param
}
