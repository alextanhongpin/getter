package main

import (
	"fmt"
	"go/types"
	"sort"
	"unicode"
	"unicode/utf8"

	"github.com/alextanhongpin/getter/loader"
	"github.com/dave/jennifer/jen"
	. "github.com/dave/jennifer/jen"
)

const Generator = "github.com/alextanhongpin/getter"

func main() {
	if err := loader.New(generateStructFromFields); err != nil {
		panic(err)
	}
}

func generateStructFromFields(opt loader.Option) error {
	var (
		pkgName    = opt.PkgName
		pkgPath    = opt.PkgPath
		out        = opt.Out
		structName = opt.StructName
		structType = opt.Type
		prefix     = opt.Prefix
	)
	f := NewFilePathName(pkgPath, pkgName)
	f.PackageComment(fmt.Sprintf("Code generated by %s, DO NOT EDIT.", Generator))

	namecache := make(map[string]bool)

	fields, err := generateStructFields(structType)
	if err != nil {
		return err
	}

	fieldNames, err := generateSortedStructFields(fields)
	if err != nil {
		return err
	}

	for _, fieldName := range fieldNames {
		field := fields[fieldName]

		fieldName, err = generateFieldNameWithPrefix(prefix, fieldName)
		if err != nil {
			return err
		}

		if field.Tag != nil && field.Tag.Inline {
			inlineStructFields, err := generateStructFields(field.Type.Underlying())
			if err != nil {
				return fmt.Errorf("%w\nhint: remove field %q from struct %q", err, field.Name, structName)
			}

			inlineFields, err := generateSortedStructFields(inlineStructFields)
			if err != nil {
				return err
			}

			inlineStructName := field.Name
			inlinePrefix := field.Tag.InlinePrefix

			for _, inlineFieldName := range inlineFields {
				inlineField := inlineStructFields[inlineFieldName]
				fieldName, err = generateFieldNameWithPrefix(prefix+inlinePrefix, inlineFieldName)
				if err != nil {
					return err
				}

				if namecache[fieldName] {
					return fmt.Errorf("duplicate field name %q", fieldName)
				}
				generateInlineGetter(f, pkgPath, structName, inlineStructName, fieldName, inlineField)
				namecache[fieldName] = true
			}
			continue
		}

		// Non-nested field cannot be exported.
		if field.Exported {
			continue
		}

		if namecache[fieldName] {
			return fmt.Errorf("duplicate field name %q", fieldName)
		}

		generateGetter(f, pkgPath, structName, fieldName, field)
		namecache[fieldName] = true
	}

	if err := f.Save(out); err != nil { // e.g. main_gen.go
		return err
	}
	fmt.Printf("success: generated %s\n", out)
	return nil
}

func generateGetter(f *jen.File, pkgPath, structName, fieldName string, field loader.StructField) {
	// Output:
	// func (e YourStruct) Name() string {
	// 	return e.name
	// }

	shortName := loader.LowerFirst(structName)[:1]

	f.Func().
		Params(Id(shortName).Id(structName)).        // (e YourStruct)
		Id(loader.UpperCommonInitialism(fieldName)). // Name
		Params().Add(generateType(field.Type)).      // (YourReturnType)
		Block(
			Return(Id(shortName).Dot(field.Name)),
		).
		Line()
}

func generateInlineGetter(f *jen.File, pkgPath, structName, inlineStructName, fieldName string, field loader.StructField) {
	// Output:
	// func (e YourStruct) Name() string {
	// 	return e.inlineStruct.name
	// }

	shortName := loader.LowerFirst(structName)[:1]

	f.Func().
		Params(Id(shortName).Id(structName)).        // (e YourStruct)
		Id(loader.UpperCommonInitialism(fieldName)). // Name
		Params().Add(generateType(field.Type)).      // (YourReturnType)
		Block(
			Return(Id(shortName).Dot(inlineStructName).Dot(field.Name)),
		).
		Line()
}

func generateFieldNameWithPrefix(prefix, fieldName string) (string, error) {
	if prefix != "" {
		p, _ := utf8.DecodeRuneInString(prefix)
		if !unicode.IsUpper(p) {
			return "", fmt.Errorf("flag value '-prefix=%s' cannot be lowercase\nhint: rename %q to %q", prefix, prefix, loader.UpperCommonInitialism(prefix))
		}
		fieldName = prefix + loader.UpperCommonInitialism(fieldName)
	}

	return fieldName, nil
}

func generateSortedStructFields(structFields map[string]loader.StructField) ([]string, error) {
	type fieldPos struct {
		name    string
		ordinal int
	}

	var fields []fieldPos
	for name, field := range structFields {
		fields = append(fields, fieldPos{
			name:    name,
			ordinal: field.Ordinal,
		})
	}

	sort.Slice(fields, func(i, j int) bool {
		return fields[i].ordinal < fields[j].ordinal
	})

	keys := make([]string, len(fields))
	for i, field := range fields {
		keys[i] = field.name
	}

	return keys, nil
}

type visitor struct {
	code *Statement
}

func newVisitor() *visitor {
	return &visitor{
		code: Null(),
	}
}

func (v *visitor) Visit(T types.Type) bool {
	switch u := T.(type) {
	case *types.Pointer:
		v.code = v.code.Op("*")
	case *types.Map:
		iv := newVisitor()
		_ = loader.Walk(iv, u.Key())
		v.code = v.code.Map(iv.code)
	case *types.Array:
		v.code = v.code.Index(Lit(u.Len()))
	case *types.Named:
		o := u.Obj()
		p := o.Pkg()
		v.code = v.code.Qual(p.Path(), o.Name())

		// We are not interested in the underlying types.
		return false
	case *types.Slice:
		v.code = v.code.Index()
	default:
		v.code = v.code.Id(u.String())
	}
	return true
}

type structVisitor struct {
	isStruct bool
	fields   map[string]loader.StructField
	err      error
}

func newStructVisitor() *structVisitor {
	return &structVisitor{}
}

func (v *structVisitor) Visit(T types.Type) bool {
	switch u := T.(type) {
	case *types.Struct:
		v.isStruct = true
		var err error
		v.fields, err = loader.ExtractStructFields(u)
		v.err = err

		// Break the walk once we found the struct.
		return false
	default:
		return true
	}
}

func generateStructFields(T types.Type) (map[string]loader.StructField, error) {
	v := newStructVisitor()
	_ = loader.Walk(v, T)
	if !v.isStruct {
		return nil, fmt.Errorf("%v is not a struct", T)
	}
	if v.err != nil {
		return nil, v.err
	}
	return v.fields, nil
}

func generateType(T types.Type) *Statement {
	v := newVisitor()
	_ = loader.Walk(v, T)
	return v.code
}
