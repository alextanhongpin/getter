package main

import (
	"fmt"
	"go/types"
	"log"
	"sort"
	"unicode"
	"unicode/utf8"

	"github.com/alextanhongpin/getter/loader"
	"github.com/dave/jennifer/jen"
	. "github.com/dave/jennifer/jen"
)

const Generator = "github.com/alextanhongpin/getter"

func main() {
	if err := loader.New(generateStructFromFields); err != nil {
		log.Fatalln(err)
	}
}

func generateStructFromFields(opt loader.Option) error {
	var (
		pkgName    = opt.PkgName
		pkgPath    = opt.PkgPath
		out        = opt.Out
		structName = opt.StructName
		structType = opt.Type
		prefix     = opt.Prefix
	)
	f := NewFilePathName(pkgPath, pkgName)
	f.PackageComment(fmt.Sprintf("Code generated by %s, DO NOT EDIT.", Generator))

	namecache := make(map[string]bool)

	structFields, err := loader.ExtractStructFields((structType.E).(*types.Struct))
	if err != nil {
		return err
	}

	fieldNames, err := generateSortedStructFields(structFields, structType)
	if err != nil {
		return err
	}

	for _, fieldName := range fieldNames {
		field := structFields[fieldName]

		fieldName, err = generateFieldName(prefix, fieldName)
		if err != nil {
			return err
		}

		if namecache[fieldName] {
			return fmt.Errorf("getter: duplicate field name %q", fieldName)
		}

		if field.Tag != nil && field.Tag.Inline {
			if !field.IsStruct {
				return fmt.Errorf("getter: inline field must be struct")
			}

			inlineStructFields, err := loader.ExtractStructFields((field.E).(*types.Struct))
			if err != nil {
				return err
			}
			inlineFields, err := generateSortedStructFields(inlineStructFields, field.Type)
			if err != nil {
				return err
			}
			inlineStructName := field.Name
			inlinePrefix := field.Tag.InlinePrefix
			for _, inlineFieldName := range inlineFields {
				inlineField := inlineStructFields[inlineFieldName]
				fieldName, err = generateFieldName(prefix+inlinePrefix, inlineFieldName)
				if err != nil {
					return err
				}

				if namecache[fieldName] {
					return fmt.Errorf("getter: duplicate field name %q", fieldName)
				}
				generateInlineGetter(f, pkgPath, structName, inlineStructName, fieldName, inlineField)
				namecache[fieldName] = true
			}
			continue
		}

		// Non-nested field cannot be exported.
		if field.Exported {
			continue
		}
		generateGetter(f, pkgPath, structName, fieldName, field)
		namecache[fieldName] = true
	}

	return f.Save(out) // e.g. main_gen.go
}

func generateGetter(f *jen.File, pkgPath, structName, fieldName string, field loader.StructField) {
	// Output:
	// func (e YourStruct) Name() string {
	// 	return e.name
	// }

	shortName := loader.LowerFirst(structName)[:1]

	f.Func().
		Params(Id(shortName).Id(structName)).            // (e YourStruct)
		Id(loader.UpperCommonInitialism(fieldName)).     // Name
		Params().Add(generateType(pkgPath, field.Type)). // (YourReturnType)
		Block(
			Return(Id(shortName).Dot(field.Name)),
		).
		Line()
}

func generateInlineGetter(f *jen.File, pkgPath, structName, inlineStructName, fieldName string, field loader.StructField) {
	// Output:
	// func (e YourStruct) Name() string {
	// 	return e.inlineStruct.name
	// }

	shortName := loader.LowerFirst(structName)[:1]

	f.Func().
		Params(Id(shortName).Id(structName)).            // (e YourStruct)
		Id(loader.UpperCommonInitialism(fieldName)).     // Name
		Params().Add(generateType(pkgPath, field.Type)). // (YourReturnType)
		Block(
			Return(Id(shortName).Dot(inlineStructName).Dot(field.Name)),
		).
		Line()
}

// Generate the field and type for primitive, map or collection.
func generateType(pkgPath string, field *loader.Type) Code {
	param := Null()

	if field.IsMap {
		key, value := field.MapKey, field.MapValue
		param = param.Map(generateType(pkgPath, key))
		param = param.Add(generateType(pkgPath, value))
		return param
	}

	if field.IsCollection {
		param = param.Index()
	}

	if field.IsPointer {
		param = param.Add(Op("*"))
	}

	// If PkgPath is empty, it will result in empty imports.
	if field.PkgPath != "" {
		param = param.Qual(field.PkgPath, field.Name)
	} else {
		param = param.Id(field.Name)
	}

	return param
}

func generateFieldName(prefix, fieldName string) (string, error) {
	if prefix != "" {
		p, _ := utf8.DecodeRuneInString(prefix)
		if !unicode.IsUpper(p) {
			return "", fmt.Errorf("getter: flag value '-prefix=%s' cannot be lowercase\nhint: rename %q to %q", prefix, prefix, loader.UpperCommonInitialism(prefix))
		}
		fieldName = prefix + loader.UpperCommonInitialism(fieldName)
	}

	return fieldName, nil
}

func generateSortedStructFields(structFields map[string]loader.StructField, structType *loader.Type) ([]string, error) {
	type fieldPos struct {
		name    string
		ordinal int
	}

	var fields []fieldPos
	for name, field := range structFields {
		fields = append(fields, fieldPos{
			name:    name,
			ordinal: field.Ordinal,
		})
	}

	sort.Slice(fields, func(i, j int) bool {
		return fields[i].ordinal < fields[j].ordinal
	})

	keys := make([]string, len(fields))
	for i, field := range fields {
		keys[i] = field.name
	}

	return keys, nil
}
